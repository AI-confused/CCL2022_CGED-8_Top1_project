# 错别字模型
参与赛道二时，针对错别字，训练了两个模型：“近形音错别字模型”和“病句错别字模型”，模型方案均采用[赛道一提供的baseline版本](https://github.com/blcuicall/CCL2022-CLTC/tree/main/baselines/track1)，只是训练数据选取，以及训练策略不同。

## 近形音错别字模型
### 数据方案
我们从公开数据集中获取一个错别字库“datas/错别字库_v1.json”，库中每个字有三组不同类型的易错字对象，常见错别字、形近字、音近字。

其中常见错别字是从任务一公布的训练集和验证集，还有开源资源[【1】](https://github.com/onebula/sighan_raw)收集而得；形近字从开源资源[【2】](https://github.com/shibing624/pycorrector)获取；音近字取lang8数据、任务一训练集和验证集所有出现汉字的top4000，使用拼音工具 pypinyin 收集而得。

### 训练增强方案
选取lang8数据中1000条数据作为验证集，其余数据作为训练集。在训练过程中，每个epoch会将所有数据的错误重新生成一次。

生成策略：如果每个句子中含有n个中文字，则生成m个错别字:
当n<5时，m为0；当n=>5生成1个错误位置，并且以5为基础，每增加10个字符增加1个错误位置；

### 如何运行
#### Train
修改`代码提交内容/src/jxy_train.py`中最下面main函数中config，运行`python3 src/jxy_train.py`。

#### Test
修改`src/jxy_test.py`中最下面main函数中config，运行`python3 src/jxy_test.py`。

### 实验记录
本模型共迭代100次，选取的第100次的结果，参与模型融合





## 病句错别字模型
### 数据方案
本模型，是采用举办方推荐的NLPCC2018-GEC12发布的lang8数据，来构造数据，进行模型训练。
[数据构造过程](src/data_ops/bju_ops.py)：

1、	每条目标样本选取一个病句样本：我们发现在lang8数据中，存在一个目标样本，对应多种病句样本的情况。采用编辑距离等策略，在1对多的情况下，选择一种错误情况，匹配成对；

2、	提取R、S类型数据：对获取的字符串对，使用任务二提供的格式转换代码，转换成S、M、R、W错误类型的格式；

3、	格式转换：在此模型训练时，我们仅加入了R、S两种类型，数据处理方式为：

    1）	将所有R对应的字符，都替换成“[unused1]”；

    2）	针对S类型，修正结果和原串错误位置长度相等，则等长替换，如果修正结果短于原串错误位置长度，则将缺失位置用“[unused1]”替换，如果修正结果长于原串错误位置长度，则将答案长的部分直接截取与原串位置等长；

将原串按上述处理，生成的字符串作为目标字符串，进行训练。

#### Train
修改`代码提交内容/src/bju_train.py`中最下面main函数中config，运行`python3 src/bju_train.py`。

#### Test
修改`src/bju_test.py`中最下面main函数中config，运行`python3 src/bju_test.py`。

### 实验记录
本模型共迭代100次，选取的第100次的结果，参与模型融合